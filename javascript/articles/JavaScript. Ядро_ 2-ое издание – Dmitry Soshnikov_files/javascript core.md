JavaScript. Ядро: 2-ое издание
http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/

###### ECMAScript — это объектно-ориентированный язык программирования с прототипной организацией, имеющий концепцию объекта в качестве базовой абстракции.

## Объект
###### Объект — это коллекция свойств, имеющая также связанный с ней объект-прототип. Прототипом может быть также другой объект, или же значение null.

На свой прототип объект ссылается посредством внутреннего свойства [[Prototype]], которое доступно в пользовательском коде через свойство __proto__.

`let point = {
  x: 10,
  y: 20,
};`

мы имеем следующую структуру с двумя явными собственными свойствами и одним неявным (внутренним) свойством __proto__, которое является ссылкой на прототип объекта point:

###### Прототипные объекты используются для реализации наследования при помощи механизма динамической диспетчеризации (dynamic dispatch). Рассмотрим понятие цепи прототипов, чтобы увидеть этот механизм в действии.

## Прототип
Каждый объект при создании получает свой прототип. Если прототип не задан явно, объекты получают базовый прототип по-умолчанию в качестве объекта наследнования.

###### Прототип — это объект-делегат, используемый для реализации прототипного наследования.

###### Цепь прототипов — это конечная цепь объектов, используемая для реализации наследования и разделяемых свойств.
Если свойство не найдено в самом объекте, осуществляется попытка разрешить (найти) это свойство в прототипе; в прототипе прототипа, и т.д. — до тех пор, пока вся цепь прототипов не будет рассмотрена. Данный механизм известен как динамическая диспетчеризация (dynamic dispatch) или делегация (delegation).
###### Делегация — механизм, используемый для разрешения свойств в цепи наследования. Процесс осуществляется во время исполнения программы, поэтому также называется динамической диспетчеризацией.
Eсли свойство в итоге не найдено во всей цепи прототипов, возвращается значение undefined:
Механизм динамической диспетчеризации также позволяет мутировать цепь наследования и менять объект-делегат:

```let protoA = {x: 10};
let protoB = {x: 20};
 
// То же, что и let objectC = {__proto__: protoA};:
let objectC = Object.create(protoA);
console.log(objectC.x); // 10
 
// Изменяем прототип:
Object.setPrototypeOf(objectC, protoB);
console.log(objectC.x); // 20
```
несмотря на то, что свойство __proto__ на сегодняшний день стандартизовано, и проще для объяснения материала, на практике рекомендовано использование API методов для манипуляции с прототипами, таких как Object.create, Object.getPrototypeOf, Object.setPrototypeOf, и схожих в модуле Reflect.

## Класс
######Класс — это формальное абстрактное множество, описывающее одинаково начальное состояние и поведение его объектов.
######Конструктор — это функция, которая используется для создания объектов и автоматической установки их прототипа.

## Контекст исполнения
######Контекст исполнения (execution context) — это абстрактное понятие, используемое спецификацией ECMAScript для типизации и разграничения исполняемого кода.
######Стек контекстов исполнения — это LIFO структура, используемая для контроля и очередности исполнения кода.

##Лексическое окружение
######Лексическое окружение (lexical environment) — это структура, используемая для ассоциации идентификаторов, появляющихся в контексте, с их значениями. Каждое лексическое окружение также может иметь ссылку на родительское окружение.
######лексическое окружение — это хранилище переменных, функций, и классов, объявленных в области видимости данного контекста.
Логически это напоминает цепь прототипов, которую мы обсуждали выше. И правило для разрешения идентификаторов (identifier resolution) очень схоже: если переменная не найдена в родном окружении, осуществляется попытка найти ее в родительском окружении, в родителе родителя, и т.д. — до тех, пока вся цепь окружений не будет рассмотрена.
######Разрешение идентификаторов (identifier resolution) — процесс поиска переменной (идентификатора) в цепи окружений. Неразрешенный идентификатор выбрасывает исключение ReferenceError.
Записи окружений различаются по типам. Так есть **объектные** записи окружений (object environment records) и **декларативные** записи окружений (declarative environment records). На базе декларативных записей также основаны **функиональные** записи окружений (function environment records) и **модульные** записи окружений (module environment records). Каждый тип записи имеет специфичные только для него свойства. Однако базовый механизм разрешения идентификаторов является общим для всех окружений, независимо от типа их записи.

Примером _объектной записи_ окружения может служить запись _глобального окружения_. Такая запись имеет ассоциированный с ней _объект связей (binding object)_, который может хранить лишь некоторые свойства из записи, но не другие, и наоборот. Объект связей может быть также использован в качестве значения **this**.

## Замыкание
Функции в ECMAScript являются объектами первого класса (first-class objects).
######Функция первого класса — функция, которая может быть использованна в качестве обычных данных: т.е. сохранена в переменную, передана в качестве аргумента, или возвращена в качестве значения из другой функции.
######Свободная переменная — переменная, не являющаяся ни параметром, ни локальной переменной данной функции.
######Статическая область видимости также называется лексической областью видмости (lexical scope) — язык программирования использует статическую область видимости, если только по анализу исходного кода, можно определить, в каком лексическом окружении будут разрешены свободные переменные.

######Замыкание — это функция, захватывающая лексическое окружение того контекста, где она создана. В дальнейшем это окружение используется для разрешения идентификаторов.

**Нисходящая фунарг-проблема**, т.е. неоднозначность, возникающая при определении правильного лексического окружения свободной переменной: должно ли это быть окружение времени создания, или же окружение времени вызова?

Данная проблема решена соглашением использования статической области видимости (static scope), т.е. окружения времени создания.

**Восходящая фунарг-проблема**. Единственное отличие здесь в том, что захваченное окружение переживает порождающий ее контекст.

Если бы не было замыкания, активационное окружение функции было бы уничтожено. Однако мы его захватили, и поэтому оно не может быть удалено, и сохраняется — для обеспечения семантики статической области видимости.

Технический механизм нисходящего и восходящего фунарга абсолютно идентичен, и является механизмом статической области видимости.

## This
######This — неявный объект контекста, доступный из кода, для возможности применения данного кода для разных объектов.

Как было отмечено, в глобальном контексте значением this является глобальный объект. И в предыдущих версиях JS был только один глобальный объект. Текущая же версия стандарта определяет множество глобальных объектов, которые являются частью областей (сфер) кода. Рассмотрим эти структуры подробней.

##Область кода (Сфера)
######Область кода (Сфера) — это объект предоставляющий отдельное глобальное окружение контексту исполнения.

##Задача
######Задача (работа) — это абстрактная операция, инициирующая ECMAScript вычисление, когда нет никаких других вычислений в данный момент.
Задачи добавляются в очереди задач (job queues), и в текущей версии спецификации существует две очереди задач: ScriptJobs (задачи скриптов), and PromiseJobs (задачи “обещаний”).

И начальная задача в очереди ScriptJobs и является главной точкой входа в нашу программу — этот тот начальный скрипт, который загружается и запускается на исполнение: создается сфера кода, создается глобальный контекст и ассоциируется с этой сферой; он помещается на стек, и происходит запуск глобального кода.

Обратите внимание, что очередь ScriptJobs обрабатывает как скрипты, так и модули.

Дальше этот контекст может создавать и запускать другие контексты или добавлять в очередь другие задачи. Примером отложенной задачи может являться обещание (promise).

Когда нет запущенных контекстов исполнения, и стек контекстов пуст, ECMAScript удаляет первую ожидающую задачу из очереди задач, создает для нее контекст исполнения и запускает ее код на исполнение.

очереди задач обычно обслуживаются абстракцией, известной как “Цикл событий” (“Event loop”). ECMAScript стандарт не описывает цикл событий, оставляя его детали реализациям, однако вы можете найти обучающий пример — здесь.

Асинхронные функции (async functions) могут ожидать (await) “обещания”, и поэтому так же добавляют задачу в очередь

##Агент
######Агент — это абстракция, инкапсулирующая в себе стек контекстов исполнения, набор очередей задач, и областей кода.

