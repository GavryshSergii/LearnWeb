
## Прототип
Каждый объект при создании получает свой прототип (свойство `__proto__`). Если прототип не задан явно, объекты получают базовый прототип по-умолчанию в качестве объекта наследнования.
> `Object.getPrototypeOf(obj)` возвращает прототип (то есть, внутреннее свойство [[Prototype]]) указанного объекта.

>`const newObj = Object.create(proto)`

###### Прототип — это объект-делегат, используемый для реализации прототипного наследования.

###### Цепь прототипов — это конечная цепь объектов, используемая для реализации наследования и разделяемых свойств.
Если свойство не найдено в самом объекте, осуществляется попытка разрешить (найти) это свойство в прототипе; в прототипе прототипа, и т.д. — до тех пор, пока вся цепь прототипов не будет рассмотрена. Данный механизм известен как динамическая диспетчеризация (dynamic dispatch) или делегация (delegation).
###### Делегация — механизм, используемый для разрешения свойств в цепи наследования. Процесс осуществляется во время исполнения программы, поэтому также называется динамической диспетчеризацией.
Eсли свойство в итоге не найдено во всей цепи прототипов, возвращается значение undefined:
Механизм динамической диспетчеризации также позволяет мутировать цепь наследования и менять объект-делегат:

```let protoA = {x: 10};
let protoB = {x: 20};
 
// То же, что и let objectC = {__proto__: protoA};:
let objectC = Object.create(protoA);
console.log(objectC.x); // 10
 
// Изменяем прототип:
Object.setPrototypeOf(objectC, protoB);
console.log(objectC.x); // 20
```
несмотря на то, что свойство __proto__ на сегодняшний день стандартизовано, и проще для объяснения материала, на практике рекомендовано использование API методов для манипуляции с прототипами, таких как Object.create, Object.getPrototypeOf, Object.setPrototypeOf, и схожих в модуле Reflect.

#### Прототипное наследование

в каждом объекте есть своство __proto__ который ссылается на другой объект (может прототип объекта?)
при обращении к свойству объекта интерпретатор:
1. проверяет наличие свойства в самом объекте  
2. если не находит его ищет дальше по ссылке которая записана в __proto__ и двигается дальше по цепочке
3. крайним объектом является Object.prototype если и в нем не обнаружено свойство возвращается undefined 
прототипная цепочка работает исключительно на чтение

