Как устроены цикл событий и стек вызовов в JavaScript
https://habr.com/ru/company/hexlet/blog/656003/

JavaScript — это однопоточный (single threaded) язык программирования с одиночным стеком вызовов. Это означает, что в один момент JavaScript может выполнять только одну операцию (обработать только один кусок кода).

Распределение памяти происходит в heap, а stack frames хранятся в стеке вызовов (call stack).

Стек вызовов создается, когда внутри функции (или метода) существуют другие функции.

Стек вызовов формируется каждый раз, когда запускается код

```
function foo() {
    throw new Error('Oops');
}

function bar() {
    foo();
}

function baz() {
    bar();
}

baz();
```

В качестве результата выполнения функция выводит на экран трассировку стека (stack trace) — состояние стека в тот момент, когда произошла ошибка. Это пример того, что называется «неполадками в стеке» (blowing the stack).

В стеке очередь вложенных функций foo, bar, baz и анонимную функцию, которая в данном случае главная.

Главная задача циклов событий (event loop) — следить за стеком и очередью задач.
Если стек пуст, цикл берет первый элемент из очереди задач  и помещает его в стек.
В очереди задач при этом находится коллбэк.

Первая сложность, с которой мы сталкиваемся — установка нулевого времени в функции setTimeout. Она ведет себя странно: переданный колбек не сразу выполняется, а попадает в очередь задач. Причина в механизме работы цикла событий: он ждет очистки стека и когда это происходит, помещает колбек в стек. Затем выполняются другие функции.

Установка нулевого времени в функции setTimeout приводит к тому, что она откладывает исполнение колбека и переносит его в конец стека.

Все web-API работают похожим образом. Например, AJAX-запрос на URL-адрес с обратным вызовом будет выполняться точно также.

XHR-запрос будет выполняться параллельно — он может быть не выполнен никогда, но стек при этом будет продолжать работать.

1. task queue
2. Stack
3. webapis
4. event loop

Вызов любой функции создаёт контекст выполнения (Execution Context). При вызове вложенной функции создаётся новый контекст, а старый сохраняется в специальной структуре данных - стеке вызовов (Call Stack).

Объекты размещаются в куче (heap) - большой неструктурированной области памяти.\

Среда выполнения JavaScript содержит очередь задач. Когда стек полностью освобождается, самая первая задача извлекается из очереди и обрабатывается. Как обычно, вызов функции создаёт новый контекст выполнения и заносится в стек вызовов.

Обработка задачи заканчивается, когда стек снова становится пустым. Следующая задача извлекается из очереди и начинается её обработка.

Модель событийного цикла (event loop) называется так потому, что отслеживает новые события в цикле queue.waitForMessage ожидает поступления задач, если очередь пуста.

Очень интересное свойство цикла событий в JavaScript, что в отличие от множества других языков, поток выполнения никогда не блокируется. Обработка I/O обычно осуществляется с помощью событий и колбэк-функций, поэтому даже когда приложение ожидает запрос от IndexedDB или ответ от XHR, оно может обрабатывать другие процессы, например пользовательский ввод.

Существуют хорошо известные исключения как alert или синхронный XHR, но считается хорошей практикой избегать их использования.
